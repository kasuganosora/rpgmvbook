# 游戏 AI 系统概述

## 什么是游戏 AI？

游戏 AI 和真正的 AI 不同：

```
真正的 AI：
┌─────────────────────────────────────┐
│ 目标：让机器"学会"思考              │
│ 方法：神经网络、深度学习            │
│ 特点：不可预测、需要大量数据        │
└─────────────────────────────────────┘

游戏 AI：
┌─────────────────────────────────────┐
│ 目标：让游戏角色"看起来"在思考      │
│ 方法：状态机、行为树、规则系统      │
│ 特点：可预测、可控、性能好          │
└─────────────────────────────────────┘
```

**核心区别**：游戏 AI 不需要真的"聪明"，只需要让玩家觉得它聪明就够了。

## 游戏 AI 的类型

| 类型 | 说明 | 例子 | 复杂度 |
|------|------|------|--------|
| **简单规则** | 固定的 if-else | 咱们能碰到就攻击 | ★ |
| **状态机** | 状态之间切换 | 巡逻→发现→追击→攻击 | ★★ |
| **行为树** | 树状决策结构 | 复杂敌人行为 | ★★★ |
| **寻路 AI** | 找到最优路径 | A* 算法 | ★★★ |
| **效用系统** | 根据权重决策 | 选择最佳技能 | ★★★★ |

## 本系列内容

| 章节 | 文件 | 内容 | 难度 |
|------|------|------|------|
| **基础概念** | [01-basics.md](01-basics.md) | AI 基本原理、设计思路 | ★ |
| **状态机** | [02-state-machine.md](02-state-machine.md) | 有限状态机 FSM 实现 | ★★ |
| **行为树** | [03-behavior-tree.md](03-behavior-tree.md) | 行为树原理与实现 | ★★★ |
| **寻路算法** | [04-pathfinding.md](04-pathfinding.md) | A* 算法详解 | ★★★ |
| **敌人 AI** | [05-enemy-ai.md](05-enemy-ai.md) | 敌人巡逻、追踪、攻击 | ★★ |
| **NPC AI** | [06-npc-ai.md](06-npc-ai.md) | NPC 对话、日程系统 | ★★ |

## 学习路线

```
第1步：理解 AI 基本概念
   ↓  知道游戏 AI 不是真正的 AI
第2步：学习状态机
   ↓  最常用的 AI 模式
第3步：学习行为树
   ↓  更灵活的 AI 结构
第4步：学习寻路
   ↓  让角色会走路
第5步：实现敌人 AI
   ↓  让敌人会战斗
第6步：实现 NPC AI
   ↓  让 NPC 有生活
```

## RPG Maker MV 的 AI 实现

RPG Maker MV 的敌人 AI 使用简单的规则系统：

```javascript
// 敌人行动选择（简化版）
Game_Enemy.prototype.selectAction = function() {
    // 1. 获取可用的行动列表
    var actions = this.enemy().actions;
    
    // 2. 过滤条件（HP 条件、回合条件等）
    actions = actions.filter(action => {
        return this.meetsCondition(action);
    });
    
    // 3. 按优先级或随机选择
    if (actions.length > 0) {
        var action = actions[Math.floor(Math.random() * actions.length)];
        return this.createAction(action);
    }
    
    // 4. 默认普通攻击
    return this.createAttackAction();
};
```

## 设计原则

### 1. 可预测性

```
好的游戏 AI：
┌─────────────────────────────────────┐
│ 玩家能理解敌人为什么会这样做        │
│ 玩家能学会如何应对敌人              │
│ 行为有一致性                        │
└─────────────────────────────────────┘

坏的游戏 AI：
┌─────────────────────────────────────┐
│ 完全随机，玩家无法学习              │
│ 行为不一致，感觉是 bug              │
│ 太简单或太难，没有中间地带          │
└─────────────────────────────────────┘
```

### 2. 性能优先

```javascript
// 坏的做法：每帧都计算寻路
function update() {
    path = findPath(enemy, player);  // 太慢！
    moveAlong(path);
}

// 好的做法：缓存结果，定期更新
function update() {
    if (pathTimer <= 0) {
        path = findPath(enemy, player);
        pathTimer = 500;  // 500ms 更新一次
    }
    pathTimer -= deltaTime;
    moveAlong(path);
}
```

### 3. 难度曲线

```
游戏初期：简单的 AI，让玩家学习
    ↓
游戏中期：中等 AI，有挑战但能赢
    ↓
游戏后期：复杂 AI，需要策略
    ↓
可选：困难模式，真正的挑战
```

## 常见问题

### Q: AI 应该多聪明？

```
答案：取决于游戏类型

休闲游戏：AI 故意犯傻，让玩家爽
竞技游戏：AI 要足够强，但不能作弊
RPG：AI 要有规律，让玩家能学习
```

### Q: AI 太难怎么办？

```
解决方法：
1. 降低 AI 反应速度
2. 减少 AI 攻击频率
3. 增加 AI 犯错概率
4. 给玩家更多提示
```

## 下一章

[AI 基础概念](01-basics.md) - 从最简单的 AI 开始。
